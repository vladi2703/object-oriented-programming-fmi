# Наследяване

При създаване на нов клас, който има общи компоненти и поведение с вече дефиниран клас, вместо новият клас да дефинира повторно тези компоненти и поведение, можем да го обявим за наследник на вече съществуващия и да ползваме функционалността на последния.  

**Пример** за наследяване:

```c++
class Person
{
private:
 char* name;
 size_t age;

 // ...

public:
 void setName(const char* name);
 void setAge(size_t age);

 const char* getName() const;
 size_t getAge() const;

 // ...
};

class Student : public Person
{
private:
 size_t fn;

public:
 void setFn(size_t fn);
 size_t getFn() const;
};
```

Класът-наследник (Student):

- съдържа всички член-данни и методи на основните класове (Person);
- получава достъп до **някои** от наследените компоненти на основните класове (Person).

![alt_text](https://i.ibb.co/PGKjkx3/st.png)

След като Student е наследник на Person, то при създаване на обект от тип Student се създава обект от тип Person, **който е част от обекта** от тип Student.

![al_text](https://i.ibb.co/z40DsMx/Inheritance.png)

## Видове наследяване

- private (по подразбиране)
- protected
- public

```c++
class A
{
public:
    int x;
protected:
    int y;
private:
    int z;
};

class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A
{
    // x is private
    // y is private
    // z is not accessible from D
};
```

( **Втора разлика между класове и структури:** Наследяването **при класове е private** по подразбиране, а **при структури - public** по подразбиране. )

## Подаване на базови класове и класове-наследници като параметри на функции

```c++
class A
{
public:
    int a;
};
class B : public A
{
public:
    int b;
};

void f(A& obj)
{
    obj.a++;
}
void g(B& obj)
{
    obj.b++;
}

int main()
{
    A obj1;
    B obj2;

    f(obj1); // OK!
    f(obj2); // OK!

    g(obj2); // OK!
    // g(obj1); // Error!
}
```

**Извод:** Класове-наследници **могат** да бъдат подавани като параметри на функции, които приемат обекти от базовия клас. Обратното е незвъзможно :bangbang:  

Същите правила важат, ако функциите приемат **A\* obj**/**B\* obj**.

## Конструктори и деструктори при наследяване

- Във всеки конструктор на класа-наследник трябва да се указва кой конструктор да се извика на базовия клас. Ако не е указано, ще се извика конструкторът по подразбиране на базовия клас **(такъв трябва да има!**).

```c++
class B : public A
{
private:
 // ...

public:
 B(...) : A(...) // constructor of A
 {
  // initialize ONLY the data members which are specific for B
 }
};
```

- Деструкторът на наследния клас извиква деструктора на базовия клас. **Първо се трият данните на класа-родител, после на класа-наследник**!

## Копиране при наследяване

При разписване на конструктора за копиране и оператора за присовяване на клас-наследник трябва експлицитно да извикваме съответно копиращия конструктор и оператора за присвояване на базовия клас.

```c++
B::B(const B& other) : A(other) // copy constructor of A
{
    copyFrom(other);
}

B& B::operator=(const B& other)
{
    if (this != &other)
    {
        A::operator=(other); // operator= of A

        free();
        copyFrom(other);
    }
    return *this;
}
```

---

## Задачи

### Задача - Фирма

**За задачата е позволено използването на std::string и std::vector**  
Една фирма е организирана по следния начин - в нея има служители (Employee), ръководители на екипи (TeamLeader), и управител (Manager). Всички с
изключение на управителя са разпределни в екипи с по точно един ръководител. Всеки екип работи върху точно един проект, и върху всеки проект се работи
от точно един екип. Реализирайте следните класове, задавайки private достъпност на член-данните им:  

- class Employee: Един служител се характеризира с име и месечна заплата.  
- class TeamLeader: Един ръководител на екип е също така и служител, но се характеризира и със съвкупност от обикновени служители - екипа, който ръководи, както и име на проекта, върху който работи екипа.
- class Manager: Управителя е и служител, но се характеризира и със съвкупност от ръководители на екипи.

- Напишете подходящи конструктори, които задават пълна информация за инициализиране на обектите. (Забележка: std::vector<Т> работи и без Т да има конструктор по подразбиране...)
- За всеки от класовете дефинирайте оператор <<, който записва данните за класа в поток. (Например данните за управителя са неговите лични данни,
както и всички проекти, които ръководи, и информация за служителите, които работят по тях).
- Напишете метод на Manager, който връща общите разходи на фирмата, както и други подходящи помощни методи в другите класове.

### Задача - Библиотека

В библиотеката на баба Минка от село Горно Нанадолнище има различни предмети (`Item`-и) - книги, списания и др. Всеки предмет си има идентификационен номер(`id`), име (`title`) и автор (`author`) и дата на публикуване (`publicationDate`). Всяка книга има свой жанр (`genre`) и уникален иден, а списанията - номер на текущия брой (`issueNumber`).
Тъй като библиотеката има богат асортимент и е трудно да се открие дали има наличен даден предмет - бабата ни моли да реализираме програмка за управление на библиотеката, която да може да извършва следните операции:

- Добавяне на нов предмет в библиотеката
- Взимане на предмет по идентификационен номер

Имената в задачата са с произволна дължина. Помислете каква структура бихте могли да използвате за да съхранявате предметите в библиотеката. За задачата не е позволено използването на `std::string` и `std::vector`.

:bulb: Можете да използвате класове, които сме реализирали в предишни упражнения

### Задача - Животни

Позволено е ползването на <cstring>  
Да се напишат класовете:

- `Animal`, който съдържа име (`char*`) и възраст (`unsigned`)
- `Pet`, който наследява `Animal` и има име на стопанин (`char*`) и телефон на стопанин (`unsigned`)  *(ако номерът започва с 0, например: 0895xxxxxx, пишем само 895xxxxxx)*

Да се реализират следните функционалности:

- големи четворки
- Принтиране в конзолата на информацията за `Pet`
- Смяна на името на дадено животно
- Смяна на стопанина на даден домашен любимец
