# Голяма петица. Предефиниране на оператори. Приятелски функции

## Move семантики

### Мотивация

Как разменяхме два обекта преди?

```cpp
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}
```

Ок, сега си представете, че искаме да имплементираме за наш клас `DynArr` оператор за размяна на два масива. Как бихме го направили?

```cpp
void swap(DynArr& a, DynArr& b) {
    DynArr temp = a;
    a = b;
    b = temp;
}
int main() {
    DynArr a(1'000'000, 1); // dynamic array with 1'000'000 elements with value 1
    DynArr b(1'000'000, 2);
    swap(a, b);
}
```

Какво се случва?

* Създаваме временен обект `temp` с размер 1'000'000
* Заделяме памет за `temp` 1'000'000
* Минаваме по всички елементи на `a` и ги копираме в `temp`

Като резултат имаме 3'000'000 копия на обекти от тип `int`. Сега си представете какво щеше да се получи, ако масивите бяха от друг, по-сложен тип.
Move семантиките ни предоставят начин да избегнем това излишно, скъпо копиране.

### `lvalue` vs `rvalue`

#### lvalue

* left value
* обект, който може да се сложи отляво на оператор за присвояване `=`
* обект, който има адрес в паметта

#### rvalue

* right value
* обект, който може да се сложи отдясно на оператор за присвояване `=`
* обект, който няма адрес в паметта
* Унищожава се след `;`

Може да си представяте `lvalue` като кутия, а `rvalue` като съдържание на кутия. Ако не приберем млякото в кутия, то бързо ще се развали. Така и с `rvalue` - ако не го приберем в кутия (`lvalue`), то ще се изгуби.

### Move конструктор

* Конструктор, който приема референция към `rvalue` като аргумент
* Целим се да прехвърлим съдържанието на `rvalue` в новосъздадения обект

Синтаксис:

```cpp
ClassName(ClassName&& other) {
    // ...
}
```

### Move оператор за присвояване

Синтаксис:

```cpp
ClassName& operator=(ClassName&& other) {
    if(this != &other) {
        // Ако не изтрием динамично заделените данни на текущия обект, ще имаме memory leak
        delete[] data; // !!!! 
        // ...
    }
    return *this;
}
```

Както и при обикновените оператори за присвояване, върнатият тип е `ClassName&`.

Сега да видим подобрената версия на `swap` функцията:

```cpp
void swap(DynArr& a, DynArr& b) {
    DynArr temp = std::move(a);
    a = std::move(b);
    b = std::move(temp);
}
```

`std::move` е функция, която приема `lvalue` и връща `rvalue` от същия тип. Тя не прави нищо особено, просто казва на компилатора, че обектът, който подаваме, е `rvalue`. По този начин форсираме компилатора да извика `move` конструктора или `move` оператора за присвояване.

## Задача 1

Имплементирайте клас матрица. Класът да има:

* Конструктор
* Деструктор
* Оператор за присвояване
* Move конструктор
* Move оператор за присвояване

Предефинирайте следните оператори:

* Оператор за индексиране - `operator()`
* Оператор за събиране - `operator+`
* Оператор за изваждане - `operator-`
* Оператор за умножение - `operator*`
* Оператор за сравнение - `operator==`
* Оператор за различност - `operator!=`

```cpp
int main() {
  Matrix a(2, 2);
  a(0, 0) = 1;
  a(0, 1) = 2;
  a(1, 0) = 3;
  a(1, 1) = 4;
  print(a);

  Matrix b(2, 2);
  b(0, 0) = 5;
  b(0, 1) = 6;
  b(1, 0) = 7;
  b(1, 1) = 8;
  print(b);

  Matrix c = a + b;
  print(c);

  Matrix d = a - b;
  print(d);

  Matrix e = a * b;
  print(e);

  if (a == b) {
    std::cout << "a is equal to b" << std::endl;
  } else {
    std::cout << "a is not equal to b" << std::endl;
  }

  Matrix f = a;
}
```
