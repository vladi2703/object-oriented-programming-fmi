# Множествено наследяване

В дадена компания има служители, които имат различни роли:

- Инженери
- Мениджъри
- Човешки ресурси

За да моделираме това като класова йерархия със знанията си до момента бихме направили следното - дефинираме си клас Служител и всеки от изброените ще наследи служител. В реалния свят обаче често се случва Инжинерите да се окажат и Мениджъри, в такъв случай - трябва да направим клас, който да наследява и от двата класа. Това се нарича множествено наследяване.
Как конструираме и разрушаваме класове с множество родители

```c++
class MyClass : SuperClass1, SuperClass2, SuperClass3, SuperClass4
{
 MyClass()
 {
  std::cout << "MyClass()" << std::endl;
 }
 ~MyClass()
 {
  std::cout << "~MyClass()" << std::endl;
 }
};

int main()
{
 MyClass obj;
}
```

Изходът от следната програма ще бъде:

```cpp
SuperClass1()
SuperClass2()
SuperClass3()
SuperClass4()
MyClass()
~MyClass()
~SuperClass4()
~SuperClass3()
~SuperClass2()
~SuperClass1()
```

В C++ имаме задължението в класовете наследници копиращия конструктор и оператор= (независимо дали ги имплементираме ние) да изглеждат така:

```c++
MyClass(const MyClass& other) : SuperClass1(other), SuperClass2(other), SuperClass3(other), SuperClass4(other)
{ 
 copyFrom(other); //copy only the MyClass stuff)
}

MyClass(const MyClass& other)
{
 if(this != &other)
 {
  SuperClass1::operator=(other);
  SuperClass2::operator=(other);
  SuperClass3::operator=(other);
  SuperClass4::operator=(other);
  free();
  copyFrom(other);
 }
}
```

При многократно наследяване на един базов клас възникват въпросите - кой точно родителски метод да извикаме? Класът `Engineer` наследява `Employee` и има метод `work()`. Класът `Manager` наследява `Employee` и има метод `work()`. Класът `ManagerEngineer` наследява `Engineer` и `Manager`. Какво ще се случи ако извикаме `work()` върху обект от тип `ManagerEngineer`? Коя от дефинициите очакваме да се извика?

Преодоляването на голяма част от недостатъците на многократното наследяване на клас се осъществява чрез използване на т.н. виртуални основни класове. Дават възможност за „поделяне“ на компонентите на основните класове. Създава се само едно тяхно копие. Декларира се като в декларацията на производния клас заедно с името и атрибута за област на основния клас се укаже и ключовата дума virtual.

```c++
class B : virtual A { ... }
class C : virtual A { ... }
```

Конструкторите с параметри на виртуални класове се извикват от конструкторите на всички класове, които са техни наследници, а не само от конструкторите на преките им наследници.

```c++
D::D(...) : B(...), C(...), A(...) {} //we call explicit the constructor of A
```

## Задача

Да се дефинират следните класове:

Клас Vehicle

- поле мощност(int)
- поле тегло(int)
- гетъри за полетата
- чисто виртуален метод startEngine

Клас Property(Собственост)

- поле собственик(std::string)
- tangible(bool) материална собственост
- гетъри за полетата

Клас Car - наследява Vehicle и Property

- поле марка и модел(от тип char*)
- голяма четворка
- метод startEngine да отпечатва "Vrooom" като за всеки 30 конски сили се отпечатва една буква "o"

Клас ElectricCar - наследява Car

- метод startEngine да отепчатва "(No Sound)".

## Задача - Библиотека

За задачата **НЕ** е позволено използването на `std::vector`.

След като [баба Минка](http://bitly.ws/F95z) успя да подреди книгите в библиотеката си, тя започна да издава членски карти в зависимост от професията на даден клиент. Нейната библиотека за момента предлага членски карти за - Студенти, Преподаватели, Асистенти и Обиковени хора. Всеки тип членска карта има различни права и отстъпки. Всеки клиент може да вземе до 3 книги едновременно. Всеки човек (`Person`) има име и ЕГН (уникален идентификатор за всеки човек. Започва от 1 за първия “родил“ се човек). Всеки студент (`Student`) има факултетен номер, всеки преподавател (`Teacher`) има съкращение на катедрата, към която преподава (`std::string`) и масив с произволна дължина от предмети, които преподава (`std::string`). Асистентите (`Assistant`) са студенти и преподаватели. Реализирайте допълнително интерфейс `BasePerson`, който да съдържа следните методи:

<details>
  <summary>Подсказка</summary>
  - display() - извежда на екрана информация за човека
  - Както всеки базов клас, така и този трябва да съдържа виртуален деструктор
  - Също така ни е нужен методът `clone()`, който да връща указател към копие на обекта
</details>

За този клас **ИМАТЕ** право да използвате `std::vector`

Реализирайте клас библиотека (`Library`), който съдържа масив с произволна дължина от членове на библиотеката (`BasePerson`). Класът трябва да може да се копира по стойност! Достатъчно е да реализирате голяма тройка, ако сметнете за необходимо. Библиотеката трябва да може да изпечатва информация за всеки един от членовете си.
