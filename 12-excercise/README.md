# Подготовка за контролно 2

- Шаблонните класове не поддържат разделна компилация

## Задача - Зоопарк

В един зоопарк има различни животни. Всеки вид животно има име, години и тегло. Всички животни трябва да се, но различно - някои хапват месо, други хапват растения, трети хапват и двете. Всички животни могат да спят, но различно - някои спят на земята, други върху дървета, трети във водата.

Реализирайте клас животно(`Animal`), който съдържа функциите:

- `int eat()` - връща колко килограма ядене е изяло животното
- `??? getFood()` - връща какво яде животното. Трябва да измислите какъв тип трябва да връща функцията

**Задължителни** Член данни:

- име (`char*`)
- тегло (`int`)

Подразбира се че **НЕ може** да създадем просто животно, без то да е от някакъв вид.
Реализирайте клас `Mamal`:

**Задължителни** Член данни:

- име на осиновител (`char*`)

Реализирайте клас `Bird`:

- име на град от който е спасена птицата (`std::string`)

Реализирайте клас `ZooSector` - сектор от зоопарка, който съдържа животни от един вид.
Всеки такъв сектор приема животни от един вид и ги съхранява в масив `std::vector`. Секторът има неограничен капацитет. Секторът има координати `x` и `y`. Секторът трябва да може да разпечата всички животни в него. Трябва да поддържа метод за добавяне на животно в сектора.

Реализирайте клас Зоопарк `Zoo`:

- име на зоопарка (`std::string`)
- съдържа масив пазещ всички животни в зоопарка - (ТУК НЕ Е ПОЗВОЛЕН ВЕКТОР)
- метод за добавяне на животно в зоопарка
- Метод за разпечатване на броя СЪЗДАДЕНИ животни
  - може някои от тези животни да не са в зоопарка. (Помислете си какво опитваме да ви накараме да си припомните с този изкуствен метод)
- Зоопарка има ограничен капацитет от ядене - цяло число килограми растения и месо.
  - `int kgOfPlants`
  - `int kgOfMeat`
- Създайте метод, който симулира нахранване на всички животни - изваждате от съответния тип ядене толкова килограма колкото всяко животно е изяло. Ако животно яде и месо и растения, то се храни със съответните килограми от двете храни.

## Задача 2 Triple
Да се реализира шаблонна структура triple, състояща се от 3 полета (first, second и third), всяко от които може да има различен произволен тип. Да се реализират още:
- Оператор <, който реализира лексикографската наредба за тройки (сравнява 2 тройки първо по first, после по second и накрая по third).
- Оператор ==, който проверява дали 2 тройки са равни. Казваме че 2 тройки са равни, ако са равни по всички елементи.
- Статична функция make_triple, която по 3 параметъра създава triple, който съдържа копия на тези елементи.
Да е презаредена с две други версии - едната приема 2 параметъра и първия присвоява на first, а втория на second и third.
Другата версия да приема един параметър и да присвоява него на first, second и third.
- Статична функция sort, която приема вектор от масив от тройки и сортира масива във възходящ ред. (не е позволено std::sort)
